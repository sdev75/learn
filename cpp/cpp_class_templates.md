## Class Templates


Considering that most of the C++ standard library is written as templates, they are one of the most powerful feature of the C++ language. Without templates, the standard would not even work. A class template are blueprints, but unlike classes, they are not a type, rather a mechanism for the C++ compiler to generate code for different types using the same blueprint or template.

The following code takes advantage of a class template to instruct the compiler to generate class defintions based on the type passed in. In this case, we are using 2 types, therefore, the compiler will generate 1 class of type `Foo<int>` and one for `Foo<double>`. There will be 2 classes in total generated by the compiler.

```c++
template <typename T>
struct Foo {
	Foo (T x) : m_x(x) {}
    Foo (const Foo<T>& rhs) : m_x(rhs.m_x) {}
    T x() const { return m_x; }
private:
    T m_x{};
};

int main(){
  	/**
     * This will generate 1 class of type Foo<int>
     * with only the methods being used by our code.
     */
	Foo<int> a{1};
	Foo<int> b{2};

  	Foo c = b;
    std::cout << c.x() << std::endl;    // 2

    Foo<double> d{12.40};
    std::cout << d.x() << std::endl;    // 12.4
  	
}
```

### Template Parameters

#### Non-type Template Parameters

It is possible for a template to use non type template parameters to enfore a specific type to be used as parameter. However, it is important to notice that when doing so, the compiler will generate code for each variation.

This can be shown by explicitly instantiate the templates using the keyword `template`, which is a technique for instructing the compiler to explicitly generate templates.

```c++
template <typename T, int bar>
struct Foo {
	Foo (T x) : m_x(x) {}
    Foo (const Foo& rhs) : m_x(rhs.m_x) {}
    T x() const { return m_x; }
private:
    T m_x{};
};

/**
 * Explicit template instantiation
 * The following will generate 3 different classes.
 * struct Foo<int, 5>
 * struct Foo<int, 10>
 * struct Foo<double, 50>
 */
template class Foo<int, 5>;
template class Foo<int, 10>;
template class Foo<double, 50>;

int main(){
  	/**
     * The same will apply when creating instances manually
     * The compiler will generate 3 different classes for 
     * each non type template paramemter, making each class
     * template unique.
     */
    Foo<int, 1> a{100};
    Foo<int, 2> b{200};
    Foo<double, 3> c{300};
}
```


### Template Specialization


#### Explicit Template Specialization

Sometimes the template itself might require a specific type to be handled differently from another. C++ allows the creation of a class template that allows customization for a given set of template arguments, this is also referred as `explicit template specialization`. An explicit template specialization is defined using the keyword `template <>`. The whole defintion will replace any other defintions, thus the class itself will become unique and will not have access to methods or members declared to the same templated class with different types.

```c++
template <typename T>
struct Foo {
    void x(){
        std::cout << "x" << std::endl;
    }
};

/**
 * template <> will define a FULL explicit specialized class.
 * The specialized class will be replaced the whole class. 
*/
template <>             
struct Foo<double> {
    void y(){
        std::cout << "y" << std::endl;
    }
};

int main(){
  	/**
     * This will generate 1 class of type Foo<int>
     * with only the methods being used by our code.
     */
    Foo<int> a;
    Foo<double> b;

    a.x();              // valid; x
    // b.x();              // error; Foo<double> has no member named x
    b.y();              // valid; y
}
```

#### Partial Template Specialization

partial template specialization allows customizing the class and variable template without losing the data already defined in a class template. This is useful when only one method requires specialization.

```c++
template <typename T>
struct Foo {
    void x(){
        std::cout << "Foo::x() for T" << std::endl;
    }
};

template <> inline
void Foo<double>::x() {
    std::cout << "Foo::x() for double" << std::endl;
}

int main(){
    Foo<int> a;
    Foo<double> b;
    a.x();          // Foo::x() for T
    b.x();          // Foo::x() for double
}
```


### Friends of Class Templates

Class template can use templated friend functions, either as member methods or global functions. This allows the generation of templated code at compile time.

```c++
template <typename T>
struct Foo {
    /**
     * Some newever compiler might not like the repetition of `<T>` in the function signature.
     * Using `friend void bar (const Foo& foo);` might solve that problem.
     */
    friend void bar<T>(const Foo<T>& foo);
private:
    int x{5};
};

template <typename T>
void bar (const Foo<T>& foo){
    std::cout << foo.x << std::endl;
}

template <typename T> 
std::ostream& operator<< (std::ostream& os, const Foo<T>& rhs){  
    os << "Foo";
    return os;
}

int main(){
    Foo<int> a;

    std::cout << a << std::endl;    // Foo
    bar(a);                         // 5
}
```

### Type Constraints

#### Static assert Trait Class Templates

It is possible to enfore compiler constraints based on the type used at compile time. Such as enforcing the type of T being either a floating point and not a pointer. You could also verify that a type is derived from another type, is integral and so on. The C++ standard library has a lot of type traits available for use.

```c++
template <typename T>
struct Foo {
    static_assert(std::is_floating_point_v<T> && 
        !std::is_pointer_v<T>, 
        "Not floating point literal");
private:
    int x{5};
};
```

### Concepts

Starting from C++20 a new feature `concepts` is introduced by the compiler. It allows named requirements to constrain template type and non-type parameter of a class and function templates.

```c++
/**
 * Enfore is_integral concept
 */
template <std::integral T>
void bar(const T t){}

/**
 * Constraint using one ore more require clauses
 *
 * We are using the predifined standard concepts `integral`
 * and `floating_point`
 */
template <typename T> requires std::integral<T> && std::floating_point<T>
void foo(const T t){}

/**
 * Type-constrained auto
 * Using baz(int) and baz(char) will instruct the compiler to
 * generate two template specialization functions of type 
 * `int` and `char` such as:
 *
 * template<> void foo<int>(int T)
 * template<> void foo<char>(char T)
 *
 */
auto baz(std::integral auto t){}

/**
 * Constraint Subsumption
 * Enfore concept on function template
 */
template <typename T>
void qux(T t) requires std::integral<T> {}
```

#### Type constrains with Class and Methods

Classes and methods can also be contrained using concepts. 

```c++
struct Foo {};
template <std::derived_from<Foo> T> struct Bar {};

template <typename T> 
requires std::derived_from<T, Foo> 
struct Baz{};  				// same result with require clause
```

Specific methods can be constrained as well:

```c++
template <typename T>
struct Foo {
    void bar() requires std::integral<T>
};
```

#### Custom concepts

New concepts can be defined using the keyword `concept`, which allows to create non-standard concepts for your programs.

```c++
template <typename T>
concept C = std::is_integral_v<V>;

template <typename T> 
requires C<T>
void foo(T t){}
C auto bar(C auto t){};
```

Concepts can also be used to validate C++ syntax.

```c++
/**
 * This will check the validity of the syntax and 
 * trigger a compiler error if the constraints are not
 * satisfied. 
 * 
 * This will validate each statement for syntax validity
 */
template <typename T>
concept C = requires (T a, T b){
    a * b;      // validate multiplication syntax
    a++;        // validate increment operator syntax
};

template <typename T> requires C <T>
void mul (T a, T b){}
```

It's important to understand that the requires clause above is merely checking for valid syntax. Therefore, putting logical statement inside the require clause might not give the desired result. 

```c++
/**
 * Simple requirements
 * A simple requirement perform assertion of an arbitraty expression statement.
 * It will not evaulate the expression itself. It will only validate its syntax.
 */
template <typename T>
concept C = requires (T t){
    /**
     * The compiler will check whether the statement is valid syntax
     * It will not execute the statement. Thus sizeof(T) could be of
     * any size, the statement would still considered valid.
     */
    sizeof(T) == 1;   

};

/**
 * Type requirements
 * The compiler will check whether the type of T has a valid certain type.
 */
template <typename T>
concept C = requires { typename T::x; };    // required nested member

template <typename T>
requires C <T>
void foo(T t){}

struct Foo { struct x {}; };


/**
 * Compound requirements
 * Compound requirements assert properties of the expression
 */
template <typename T>
concept C = requires(T t) {
    {t} -> std::convertible_to<int>;	// {x} must be a valid expression
					// The result of must be convertible to integer
};


/**
 * Nested requirements
 * Unlike simple requirements, nested requirements allow the constraint-expression to be
 * evaluated and validated
 */
template <typename T>
concept C = requires (T t){
    sizeof(T) == 1;   

    /**
     * Evalutates the expression to determine if the constraint-expression is satified.
     * In this case, if the sizeof T <= 8, the constraint will not satisfy.
     */    
    requires sizeof(T) > 8; 
};

```


#### Combining Concept Expressions

Two or more concepts can be combined together using conjunctions `&&` and disjunctions `||`. This allows to reuse existing concepts and using logical operator to build more powerful concepts.

```c++
template <typename T>
concept C = std::integral<T> && std::floating_point<T>

/**
 * Combining standard concepts with custom inlined concept
 * The param T will only be valid as long as the syntax is validated
 * and the sizeof(T) is equal to 8 bytes. In this case a double value would do.
*/
template <typename T>
void foo (T t) requires std::integral<T> &&
    requires (T t) {                // custom inline concept 
         sizeof(T) == 4;            // validate syntax
         requires sizeof(T) == 8;   // validate expression
    }
{}                                  // body of function

```

### Class Templates with Concepts

Classes can make use of the concept introduced in C++20 to enfore constraints.

```c++
template <typename T>
requires std::is_default_constructible_v<T>
struct Foo {};

struct Bar {
    Bar()=delete;
    Bar(){};
};
```

Concepts can also help ensuring a certain function has the functionality required to satisfy the constraints.

```c++
struct Bar{ double x; };
struct Baz{ int x; };
struct Qux{};

template <typename T>
concept Streamable = requires (std::ostream& os, T& t) {
    os << t;
    requires sizeof(T) == 8;
};

template <typename T>
struct Foo {
    /** 
     * Implicitly Streamable, but it wont enforce nested constraints
     * Commenting out this method would cause an error:
     *   template<class T>  requires  Streamable<T> 
     *
     * The compiler will enfore the constraint on the global operator first
     * and use the overloaded friend function without enforcing again the 
     * same constraints. After all, the method we're definding below is 
     * what makes the code satisfy our constraint-expression.
     * T = class Bar
     */
    friend std::ostream& operator<< (std::ostream& os, const Foo<T>& t)
    requires (std::same_as<T,Bar>) {
        os << "T = streamable && T = " << typeid(t.m_t).name();
        return os;
    } 

    /** 
     * Implicitly required to be Streamable
     * T = class Baz && T = 4 bytes
     */
    friend std::ostream& operator<< (std::ostream& os, const Foo<T>& t)
    requires (
        std::same_as<T,Baz> && 
        requires {
            requires sizeof(T) == 4;    // nested requirement
        }) {
        os << "T = 4 bytes && T = " << typeid(t.m_t).name();
        return os;
    } 
private:
    T m_t;
};


template <Streamable T>
std::ostream& operator<< (std::ostream& os, const Foo<T>& foo){
    os << "operator<< (ostream, Foo<T>) invoked";
    return os;
}

int main(){
    Foo<Bar> a; operator<<(std::cout, a) << "\n";   // valid; T = streamable && T = 3Bar
    Foo<Baz> b; std::cout << b << "\n";             // valid; T = 4 bytes && T = 3Baz
    //Foo<int> c; operator<<(std::cout, c) << "\n"; // error; requires Streamable<T>
    Foo<long> d; operator<<(std::cout, d) << "\n";  // valid; operator<< (ostream, Foo<T>) invoked
    //Foo<Qux> e; operator<<(std::cout, e) << "\n"; // error; requires Streamable<T>
}
```

