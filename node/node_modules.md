## Node.js and modules

Node.js uses the `require()` function in order to manage module imports and dependency between packages. Using modules is an important part of Node.js allowing the code to be modular, thus easy to be maintained.

### The main module

Whenever a file is ran directly using Node.js, such as `node foo.js`, the `module` object is filled out with information about `foo.js`:

```js
Module {
  id: '.',
  path: '/foo/bar/baz',
  exports: {},
  parent: null,
  filename: '/foo/bar/baz/foo.js',
  loaded: false,
  children: [],
  paths: [
    '/foo/bar/baz/node_modules',   // 1st path for require() lookups
    '/foo/bar/node_modules',       // 2nd path for require() lookups
    '/foo/node_modules',           // 3rd path for require() lookups
    '/node_modules'                // last path for require() lookups
  ]
}
```

```js
[Function: require] {
  resolve: [Function: resolve] { paths: [Function: paths] },
  main: Module {
    id: '.',
    path: '/foo/bar/baz',
    exports: {},
    parent: null,
    filename: '/foo/bar/baz/foo.js',
    loaded: false,
    children: [],
    paths: [
      '/foo/bar/baz/node_modules',
      '/foo/bar/node_modules',
      '/foo/node_modules',
      '/node_modules'
    ]
  },
  extensions: [Object: null prototype] {...},
  cache: [Object: null prototype] {...}
}
```

Calling the file directly from the command line would result in the following truthy statement: `console.log(require.main === module);`. However, requiring the same file using the `require()` function would return false.

For example `node foo.js` with `foo.js` having `require('./baz.js')` would result in the following:

```js
<ref *1> Module {
  id: '.',
  path: '/foo/baz/bar',
  exports: {},
  parent: null,
  filename: '/foo/baz/bar/foo.js',
  loaded: false,
  children: [
    Module {
      id: '/foo/baz/bar/baz.js',
      path: '/foo/baz/bar',
      exports: {},
      parent: [Circular *1],
      filename: '/foo/baz/bar/baz.js',
      loaded: true,
      children: [],
      paths: [Array]
    }
  ],
  paths: [
    '/foo/baz/bar/node_modules',
    '/foo/baz/node_modules',
    '/foo/node_modules',
    '/node_modules'
  ]
}
```

In this case `require.main` would be set to the file that started the dependency tree. This can be always checked with the property `require.main.filename`.

The require algorithm is quite simple, yet it makes the Node.js module system very powerful treating each file as a separate module. This algorithm allows to load a module depending on where the module is loaded from. There are 3 types of modules recognized by the algorithm:

- **Core Modules**

  - Core modules are part of the Node binary package and usually located in the lib folder. They are not prefixed with an absolute or relative path. Any require calls without the `/` or `./` prefix will make the algorithm search within the Node.js core modules first. For example: `require('http')`.

- **File Modules**

  - File modules are prefixed with either an absolute path or a relative path, `/` or `./` respectively. The algorithms attempts to locate the module by trasversing all the paths indicated in `require.main.paths`. If the module requested without any extensions is not found, then Node.js will attempt to load the required filename with the added extensions: .js, .json, and finally .node. More info on the exact algorithm can be found at `https://nodejs.org/api/modules.html`.

A file module prefixed with an absolute path `/`, for example: `require('/foo/bar/baz/foo.js')` will attempt load the file located at `/foo/bar/baz/foo.js`.

### File modules

A file module prefixed with a relative path `./`, for example `./foo.js`, will attempt to load the file located in the the same directory of the file requiring the file for Node.js to find it.

When loading file modules, files with a .js extension are interpreted as Javascript text files. Files with the .json extension are parsed as JSON text file. Addon modules are loaded with `process.dlopen()` and they have the `.node` extension. Node.js attempts to load each extension in the respective order and stops as soon as a matching file is found.

If no file module is found, require() will throw an Errro with the code property set to 'MODULE_NOT_FOUND'.

### Folders as module

Node.js allows modules to be organized into self-contained directories, with every directory having a single entry point to those directories.

It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to those directories. Within the self-contained Node.js will first attempt to load the main entry point using a `package.json` file. If there is no package.json or if the `main` entry point is missing, then it will attempt to locate an `index.js` and then an `index.node`. If any of those files are missing, then Node.js will report the entire module as missing with an error message.

### Loading modules from node_modules folder

When a module identifier requested is not a core module or a file module, then Node.js will check if the file exists in the "node_modules" directory within the current module, and then attempt to find a matching file by trasversing all parent node_modules folders up until the root of the file system is reached.

For example:

```js
require("bar"); // bar being an identifier, either module path or name
```

The above statement will make the require algorithm to look for a core module first. If no core module is found, then Node.js will look in the following paths (assuming the file requesting foo is located in: /foo/bar/baz/foo.js)

1. /foo/bar/baz/node_modules/bar (and all possible variants)
2. /foo/bar/node_modules/bar (and all possible variants)
3. /foo/node_modules/bar (and all possible variants)
4. /node_modules/bar (and all possible variants)

## Module exports

### Named exports

Named exports are the basic method for exposing public API functionality:

```js
// foo.js
exports.foo = function () {};

// bar.js
exports.bar = function () {};
```

These modules would then be loaded using `require()` as follows:

```js
foo = require("./foo");
bar = require("./bar");
```

### Exporting functions

Another common module definition pattern consists in ressigning the whole module.exports property to a function as follows:

```js
// foo.js
module.exports = function () {
  console.log("foo module");
};

// alternative way:
module.exports.foo = function () {};
```

### Exporting an instance and caching

Node.js modules can leverage the caching mechanism of `require()`. Every module requested using `require()` is cached, loading the module only once. Every module that requires `Foo` will share the same instance, thus sharing the state of the `Foo` object as well.

Adding or replacing entries is also possible. This cache is checked before native modules and if a name matching a native module is added to the cache, no require call is going to receive the native module anymore. Use with care!

```js
// foo.js
function Foo() {
  this.bar = 0;
}
Foo.prototype.printCache = function () {
  console.log(require.cache[module.id].exports);
};
module.exports = new Foo();
```

```js
// index.js
foo = require("./foo"); // get new instance, then save in require.cache
console.log(foo.bar); // 0
foo.bar = 100; // the actual cached object will be modified
foo.baz = 200; // `baz` will preserve across require() calls

foo = require("./foo"); // fetching Foo instance from require.cache
console.log(foo.bar); // 100
console.log(foo.baz); // 200
```

The contents of the cache could be displayed by accessing the cache property of the require object as follows `require.cache[module.id].exports)`. This would be called within the module itself, so that module.id would refer to the current module.

### Exporting a constructor

Exporting a constructor allows the module to be instantiated and extended using the prototype chain:

```js
function Foo() {}

Foo.prototype.bar = function () {
  console.log("this is bar from Foo");
};

module.exports = Foo;
```

```js
console.log(require.main.paths);
var Foo = require("./foo");
const foo = new Foo();
foo.bar();
```
